#!/bin/sh

TS_PROGNAME="${0##*/}"

ts_usage () {
  if [ "$TS_PROGNAME" = ts ]; then
    local args="[<test-file>...]"
    local examples="\
  ts test_*     # run test functions of multiple test files
  test_1        # run test functions of a single test file
  test_1 fn_a   # run selected test function of the test file
"
  else
    local args="[<test-function>...]"
    local examples="\
  $TS_PROGNAME                 # run all test functions
  $TS_PROGNAME <fn_a>          # run a single test function
  $TS_PROGNAME <fn_a> <fn_b>   # run selected test functions
"
  fi
  echo "\
Run shell functions as tests.
usage: $TS_PROGNAME [-h|-l|-dikqv] [-t <tmp-dir>] $args

$examples
options:

  -d  debug output (print shell trace)
  -h  print this help
  -i  interacive stops after tests
  -k  keep tmp dir
  -l  list tests
  -q  quiet output (hide stderr)
  -t  set the tmp dir (default ./tmp)
  -v  verbose output (print stdout)
"
}

while getopts "dhiklqt:v" option; do
  case "$option" in
    d) TS_DEBUG=1; TS_VERBOSE=1 ;;
    h) ts_usage
       exit 0 ;;
    i) TS_INTERACTIVE=1 ;;
    k) TS_KEEP_TMP_DIR=1 ;;
    l) TS_LIST=1 ;;
    q) TS_QUIET=1 ;;
    t) TS_TMP_DIR=$OPTARG ;;
    v) TS_VERBOSE=1 ;;
    *) ts_usage | head -n 1
       exit 2 ;;
  esac
done
shift $((OPTIND - 1))

TS_TOP_DIR="${TS_TOP_DIR:-$PWD}"
TS_TMP_DIR="${TS_TMP_DIR:-$TS_TOP_DIR/tmp}"

# private functions
###############################################################################

# Prints all functions in a file starting with 'test_' or $test_pattern.
ts_list () {
  local file="$1"
  shift
  local test_pattern=$(printf "$*" | tr " " "|")
  grep -onE "^[[:space:]]*(${test_pattern:-test_\w+})[[:space:]]*\(\)" /dev/null "$file" |
  sed -e 's/^\([^:]*\):\([0-9]\{1,\}\):[[:space:]]*\([^ (]\{1,\}\).*/\3 \1:\2/'
}

# Runs a specific test.
ts_run_test () {
  local test_name="$1"

  # input /dev/null so that tests which read from stdin will not hang
  exec </dev/null
  # use fd3 for tap comments
  if [ "$TS_VERBOSE" ]; then
    exec 3>&1 1>&2
  elif [ "$TS_QUIET" ]; then
    exec 3>&1 1>/dev/null 2>&1
  else
    exec 3>&1 1>/dev/null
  fi

  if [ "$TS_DEBUG" ]; then
    set -ux
  else
    set -u
  fi

  trap 'teardown' EXIT
  setup && "$test_name"
  local exit_status=$?
  trap - EXIT
  teardown && return $exit_status
}

ts_run_test_functions () {
  local test_file="$0"
  local test_case="${test_file##*/}"
  test_case="${test_case%\.*}"

  local case_dir="$TS_TMP_DIR/$test_case"
  if ! [ "$TS_LIST" ] && ! rm -rf "$case_dir"; then
    echo "error: could not clean existing test dir: $case_dir"
    exit 1
  fi

  local test_cnt=1
  local test_plan=$(ts_list "$test_file" "$@" | wc -l | xargs)
  if ! [ "$TS_LIST" ]; then
    echo "$test_cnt..$test_plan"
  fi
  ts_list "$test_file" "$@" |
  while read test_name test_desc; do
    if [ "$TS_LIST" ]; then
      echo "[$test_desc] $test_name"
      continue
    fi

    TS_TEST_DIR="$case_dir/$test_name"
    mkdir -p "$TS_TEST_DIR"

    if [ "$TS_VERBOSE" ]; then
      >&2 echo "# $test_cnt $test_name [$test_desc]"
    fi
    # run the test by calling back into the test file
    # use a subprocess to prevent leakage (eg set -x)
    # a zero exit status is considered a pass, otherwise fail
    {
      (ts_run_test $test_name) || touch "$TS_TEST_DIR"/fail
    } 2>&1 | sed "s/^/# /" >&2

    if ! [ -e "$TS_TEST_DIR"/fail ]; then
      if [ -e "$TS_TEST_DIR"/skip ]; then
        local reason="$(cat "$TS_TEST_DIR"/skip)"
        if [ "$reason" ]; then
          status="ok $test_cnt $test_name # skip $reason"
        else
          status="ok $test_cnt $test_name # skip"
        fi
      else
        status="ok $test_cnt $test_name"
      fi
    else
      status="not ok $test_cnt $test_name"
      touch "$case_dir"/fail
    fi
    echo "$status"
    test_cnt=$((test_cnt + 1))

    if [ "$TS_INTERACTIVE" ]; then
      read x < /dev/tty
    fi
  done

  local result=0
  if [ -e "$case_dir"/fail ]; then
    result=1
  fi
  if ! [ "$TS_LIST" ] && ! [ "$TS_KEEP_TMP_DIR" ]; then
    rm -rf "$case_dir"
  fi
  return $result
}

ts_run_test_files () {
  export TS_TOP_DIR
  export TS_TMP_DIR
  export TS_DEBUG
  export TS_INTERACTIVE
  export TS_KEEP_TMP_DIR
  export TS_LIST
  export TS_QUIET
  export TS_VERBOSE

  local error
  for test_file in "$@"; do
    if [ -f "$test_file" ]; then
      if [ -x "$test_file" ]; then
        if [ "${test_file}" = "${test_file#*/}" ]; then
          ./"$test_file"
        else
          "$test_file"
        fi
      else
        echo "error: $test_file not executable"
        error=1
        continue
      fi
    else
      echo "error: $test_file not a file"
      error=1
      continue
    fi
  done
  if [ "$error" ]; then
    exit 1
  fi
}

ts_indent () {
  echo "$1" | sed "s/^/  /"
}

# public functions
###############################################################################

if ! type "setup" >/dev/null 2>&1; then
setup () { :; }
fi

if ! type "teardown" >/dev/null 2>&1; then
teardown () { :; }
fi

skip () {
  local reason="${1:-}"
  printf "$reason\n" > "$TS_TEST_DIR"/skip
  exit 0
}

expect_status () {
  eval "$1"
  local actual=$?
  local expect="${2:-0}"
  if [ $actual = $expect ]; then
    return
  fi
  >&3 echo "expect_status failed"
  >&3 ts_indent "$1"
  >&3 echo " actual   $actual"
  >&3 echo " expected $expect"
  exit 1
}

expect_output () {
  local actual="$(eval "$1")"
  local expect="$2"
  if [ "$actual" = "$expect" ]; then
    return
  fi
  >&3 echo "expect_output failed"
  >&3 ts_indent "$1"
  >&3 echo " actual"
  >&3 ts_indent "$actual"
  >&3 echo " expected"
  >&3 ts_indent "$expect"
  exit 1
}

expect_value () {
  eval local actual="$1"
  local expect="$2"
  if [ "$actual" = "$expect" ]; then
    return
  fi
  >&3 echo "expect_value failed"
  >&3 ts_indent "$1"
  >&3 echo " actual"
  >&3 ts_indent "$actual"
  >&3 echo " expected"
  >&3 ts_indent "$expect"
  exit 1
}

# Run the given test files or this script as single suite.
###############################################################################

if [ ts = "$TS_PROGNAME" ]; then
  ts_run_test_files "$@"
else
  ts_run_test_functions "$@"
fi
