#!/bin/sh

ts_progname="${0##*/}"
ts_version="2.0.1"
ts_url="http://github.com/thinkerbot/ts"

ts_usage () {
  if [ "$ts_progname" = ts ]; then
    ts_arg_expr="[TEST_FILES...]"
  else
    ts_arg_expr="[TEST_NAMES...]"
  fi
  printf "\
usage: ts [-dhkv] [-t TS_TMP_DIR] %s

  Tests shell scripts.

    ts test/script*             # run multiple test scripts
    ./test/script               # run a single test script
    ./test/script test_a        # run a single test

options:

    -d  debug output
    -h  print this help
    -k  keep tmp dir
    -t  set the tmp dir (default tmp)
    -v  verbose output

version: %s - %s
" "$ts_arg_expr" "$ts_version" "$ts_url"
}

while getopts "dehkt:v" ts_option; do
  case "$ts_option" in
    d) TS_DEBUG=1; TS_VERBOSE=1 ;;
    h) ts_usage
       exit 0 ;;
    k) TS_KEEP_TMP_DIR=1 ;;
    t) TS_TMP_DIR=$OPTARG ;;
    v) TS_VERBOSE=1 ;;
    *) ts_usage | head -n 1
       exit 2 ;;
  esac
done
shift $((OPTIND - 1))

TS_USR_DIR="${TS_USR_DIR:-$PWD}"
TS_TMP_DIR="${TS_TMP_DIR:-$TS_USR_DIR/tmp}"

# private functions
###############################################################################

# Prints all functions in a test file starting with 'test_' or $ts_test_pattern.
ts_list () {
  local ts_file="$1"
  shift 1
  local ts_test_pattern=$(printf "$*" | tr " " "|")
  grep -onE "^[[:space:]]*(${ts_test_pattern:-test_\w+})[[:space:]]*\(\)" /dev/null "$ts_file" |
    sed -e 's/^\([^:]*\):\([0-9]\{1,\}\):[[:space:]]*\([^ (]\{1,\}\).*/\3 \1:\2/'
}

# Runs a specific test.
ts_run_test () {
  local ts_test_name="$1"

  # input /dev/null so that tests which read from stdin will not hang
  exec </dev/null

  if [ "$TS_DEBUG" ]; then
    set -ux
  else
    set -u
  fi

  trap 'teardown' EXIT
  setup && "$ts_test_name"
  ts_exitstatus=$?
  trap - EXIT
  teardown && return $ts_exitstatus
}

ts_run_test_suite () {
  local ts_test_file="$0"
  local ts_test_case="${ts_test_file##*/}"
  ts_test_case="${ts_test_case%\.*}"

  local ts_case_dir="$TS_TMP_DIR/$ts_test_case"
  if ! rm -rf "$ts_case_dir"; then
    echo "error: could not clean existing test dir: $ts_case_dir"
    exit 1
  fi

  ts_list "$ts_test_file" "$@" |
  while read ts_test_name ts_test_desc; do

    TS_TEST_DIR="$ts_case_dir/$ts_test_name"
    mkdir -p "$TS_TEST_DIR"

    # run the test by calling back into the test file
    # use a subprocess to prevent leakage (eg set -x)
    # use stdout for progress, stderr for debug information
    if [ "$TS_VERBOSE" ]; then
      (ts_run_test $ts_test_name >/dev/null)
    else
      (ts_run_test $ts_test_name >/dev/null 2>&1)
    fi
    # a zero exit status is considered a pass, otherwise fail
    if [ $? -eq 0 ]; then
      if [ -e "$TS_TEST_DIR"/skip ]; then
        ts_status=S
      else
        ts_status=P
      fi
    else
      ts_status=F
      touch "$ts_case_dir"/fail
    fi
    echo "$ts_status [$ts_test_desc] $ts_test_name"
  done

  local ts_result=0
  if [ -e "$ts_case_dir"/fail ]; then
    ts_result=1
  fi
  if ! [ "$TS_KEEP_TMP_DIR" ]; then
    rm -r "$ts_case_dir"
  fi
  return $ts_result
}

ts_run_test_files () {
  export TS_USR_DIR
  export TS_TMP_DIR
  export TS_KEEP_TMP_DIR
  export TS_DEBUG
  export TS_VERBOSE

  for ts_test_file in "$@"; do
    if [ -f "$ts_test_file" ]; then
      if [ -x "$ts_test_file" ]; then
        if [ "${ts_test_file}" = "${ts_test_file#*/}" ]; then
          ./"$ts_test_file"
        else
          "$ts_test_file"
        fi
      else
        echo "S [$ts_test_file] not executable"
      fi
    else
      echo "S [$ts_test_file] not a file"
    fi
  done
}

# public functions
###############################################################################

if ! type "setup" &>/dev/null; then
setup () { :; }
fi

if ! type "teardown" &>/dev/null; then
teardown () { :; }
fi

# Flunks unless the numbers $1 (expected) and $2 (actual) are the same.
assert_status () {
  local ts_expected=$1
  local ts_actual=$2
  local ts_msg
  if ! [ $ts_actual -eq $ts_expected ]; then
    shift 2
    if [ $# -ne 0 ]; then
      ts_msg=" ($*)"
    fi
    echo "expected status $ts_expected but was $ts_actual$ts_msg" >&2
    exit 1
  fi
}

# Flunks unless the variables $1 (expected) and $2 (actual) are the same.
# Reads from stdin for '-'.  '-' is assumed if $2 is not specified.
assert_output () {
  local ts_expected="$1"
  local ts_actual="${2:--}"
  if [ "$ts_expected" = - ]; then
    ts_expected=$(cat)
  fi
  if [ "$ts_actual" = - ]; then
    ts_actual=$(cat)
  fi
  if [ "$ts_actual" != "$ts_expected" ]; then
    return 1
  fi
}

skip () {
  local ts_reason="$1"
  printf "$ts_reason\n" > "$TS_TEST_DIR"/skip
  exit 0
}

# Run the given test files or this script as single suite.
###############################################################################

if [ ts = "$ts_progname" ]; then
  ts_run_test_files "$@"
else
  ts_run_test_suite "$@"
fi
