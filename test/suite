#!/bin/sh
. test/helper

#
# ts test
#

test_ts_runs_file () {
  expect_output "test/cases/ok" \
    "ok test_pass"
}

test_ts_runs_file_in_pwd () {
  mkdir -p "$TS_TEST_DIR"
  sed -e '/helper/d' test/cases/ok > "$TS_TEST_DIR/pass"
  chmod +x "$TS_TEST_DIR/pass"

  cd "$TS_TEST_DIR"
  expect_output "ts pass" \
    "ok test_pass"
}

test_ts_runs_multiple_files () {
  expect_output "ts test/cases/ok test/cases/not_ok" "\
ok test_pass
not ok test_fail"
}

test_ts_runs_tests_with_same_name_in_different_files () {
  expect_output "ts test/cases/xyz_one test/cases/xyz_two" "\
ok test_xyz
not ok test_xyz"
}

test_ts_reports_non_executable_files () {
  expect_output "ts test/cases/nox" \
    "error: test/cases/nox not executable"
}

test_ts_reports_non_files () {
 expect_output "ts test test/miss" "\
error: test not a file
error: test/miss not a file"
}

test_script_runs_tests () {
  expect_output "test/cases/abc" "\
ok test_a
ok test_b
not ok test_c
ok test_s # skip s"
}

test_script_runs_named_tests () {
  expect_output "test/cases/abc test_a test_c" "\
ok test_a
not ok test_c"
}

test_script_runs_tests_matching_patterns () {
  expect_output 'test/cases/abc "test_[ac]"' "\
ok test_a
not ok test_c"
}

#
# options test
#

test_ts_h_prints_help () {
  expect_status 'ts -h | grep -q "usage:"' 0
}

test_script_h_prints_help () {
  expect_status 'test/cases/ok -h | grep -q "usage:"' 0
}

#
# exit status test
#

test_ts_exits_0_for_passing_test () {
  expect_status "ts test/cases/ok" 0
}

test_ts_exits_1_for_failing_test () {
  expect_status "ts test/cases/ok" 0
}

test_script_exits_0_for_passing_test () {
  expect_status "test/cases/ok" 0
}

test_script_exits_1_for_failing_test () {
  expect_status "test/cases/not_ok" 1
}

test_ts_exits_1_for_non_executable_files () {
  expect_status "ts test/nox" 1
}

test_ts_exits_1_for_non_files () {
  expect_status "ts test test/miss" 1
}

#
# testcases
#

case_output () {
  sed -n 's/#-> *//p' $1
}

test_case_change_dirs () {
  local test=test/cases/change_dirs
  expect_output $test "$(case_output $test)"
}

test_case_exit_fail_in_setup () {
  local test=test/cases/exit_fail_in_setup
  expect_output $test "$(case_output $test)"
}

test_case_return_fail_in_setup () {
  local test=test/cases/return_fail_in_setup
  expect_output $test "$(case_output $test)"
}

test_case_exit_fail_in_test () {
  local test=test/cases/exit_fail_in_test
  expect_output $test "$(case_output $test)"
}

test_case_exit_fail_in_test_after_untrap () {
  local test=test/cases/exit_fail_in_test_after_untrap
  expect_output $test "$(case_output $test)"
}

test_case_exit_fail_in_teardown () {
  local test=test/cases/exit_fail_in_teardown
  expect_output $test "$(case_output $test)"
}

test_case_return_fail_in_teardown () {
  local test=test/cases/return_fail_in_teardown
  expect_output $test "$(case_output $test)"
}

test_case_fail () {
  local test=test/cases/fail
  expect_output $test "$(case_output $test)"
}

test_case_pass () {
  local test=test/cases/pass
  expect_output $test "$(case_output $test)"
}

test_case_skip () {
  local test=test/cases/skip
  expect_output $test "$(case_output $test)"
}

test_case_test_detection () {
  local test=test/cases/test_detection
  expect_output $test "$(case_output $test)"
}

test_case_public_function_conflict () {
  local test=test/cases/public_function_conflict
  expect_output $test "$(case_output $test)"
}

test_case_undeclared_variable () {
  local test=test/cases/undeclared_variable
  expect_output $test "$(case_output $test)"
}

#
# misc tests
#

test_ts_prevents_hang_by_stdin () {
  # cat hangs if stdin is waiting
  local from_stdin=$(cat)
  expect_value '$from_stdin' ""
}

test_ts_allows_exit_trap () {
  trap "exit 0" EXIT
  exit 1
}

. bin/ts
